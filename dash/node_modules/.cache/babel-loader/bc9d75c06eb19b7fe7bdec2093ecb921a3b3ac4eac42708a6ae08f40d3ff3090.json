{"ast":null,"code":"var _SCALE_FUNCTIONS;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\nimport PropTypes from 'prop-types';\nimport { warning } from \"./react-utils\";\nimport { getUniquePropertyValues, addValueToArray } from \"./data-utils\";\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\n\nvar LINEAR_SCALE_TYPE = 'linear';\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\n\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n/**\n * Category scale.\n * @type {string}\n * @const\n */\n\nvar CATEGORY_SCALE_TYPE = 'category';\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\n\nvar LITERAL_SCALE_TYPE = 'literal';\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\n\nvar LOG_SCALE_TYPE = 'log';\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_SCALE_TYPE = 'time';\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\n\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\n\nfunction toTitleCase(str) {\n  return \"\".concat(str[0].toUpperCase()).concat(str.slice(1));\n}\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\n\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n  if (scaleFn) {\n    var nextValue;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance;\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n      currentValue = nextValue;\n    }\n  }\n  return result;\n}\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n      _scale$range2 = _slicedToArray(_scale$range, 2),\n      lower = _scale$range2[0],\n      upper = _scale$range2[1];\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\n\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n  var type = scaleObject.type,\n    domain = scaleObject.domain,\n    range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n  return scale;\n}\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\n\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain; // Collect both attr and available attr0 values from the array of data.\n\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n    return data;\n  }, []);\n  if (!values.length) {\n    return [];\n  } // Create proper domain depending on the type of the scale.\n\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n  return domain;\n}\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\n\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n  if (typeof value === 'undefined') {\n    return null;\n  }\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\n\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n    range = _ref.range,\n    type = _ref.type,\n    distance = _ref.distance,\n    attr = _ref.attr,\n    baseValue = _ref.baseValue,\n    accessor = _ref.accessor,\n    accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\n\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n    fallbackValue = props[\"_\".concat(attr, \"Value\")],\n    range = props[\"\".concat(attr, \"Range\")],\n    _props$ = props[\"\".concat(attr, \"Distance\")],\n    distance = _props$ === void 0 ? 0 : _props$,\n    baseValue = props[\"\".concat(attr, \"BaseValue\")],\n    _props$2 = props[\"\".concat(attr, \"Type\")],\n    type = _props$2 === void 0 ? LINEAR_SCALE_TYPE : _props$2,\n    noFallBack = props[\"\".concat(attr, \"NoFallBack\")],\n    _props$3 = props[\"get\".concat(toTitleCase(attr))],\n    accessor = _props$3 === void 0 ? function (d) {\n      return d[attr];\n    } : _props$3,\n    _props$4 = props[\"get\".concat(toTitleCase(attr), \"0\")],\n    accessor0 = _props$4 === void 0 ? function (d) {\n      return d[\"\".concat(attr, \"0\")];\n    } : _props$4;\n  var domain = props[\"\".concat(attr, \"Domain\")]; // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[\"\".concat(attr, \"Type\")], accessor, accessor0);\n  } // Pick up the domain from the properties and create a new one if it's not\n  // available.\n\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  } // Make sure that the minimum necessary properties exist.\n\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[\"\".concat(attr, \"Type\")], accessor, accessor0);\n  }\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\n\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n  return 0;\n}\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\n\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n  return values;\n}\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\n\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n    type = scaleObject.type,\n    accessor = scaleObject.accessor,\n    accessor0 = scaleObject.accessor0;\n  var uniqueValues = getUniquePropertyValues(data, accessor); // Fix time scale if a data has only one value.\n\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values); // Fix log scale if it's too small.\n\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n  var adjustedScaleFn = getScaleFnFromScaleObject(_objectSpread(_objectSpread({}, scaleObject), {}, {\n    domain: adjustedDomain\n  }));\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\n\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n    adjustBy = _props$_adjustBy === void 0 ? [] : _props$_adjustBy,\n    _props$_adjustWhat = props._adjustWhat,\n    adjustWhat = _props$_adjustWhat === void 0 ? [] : _props$_adjustWhat; // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n    _props$_adjustWhat2 = props._adjustWhat,\n    adjustWhat = _props$_adjustWhat2 === void 0 ? [] : _props$_adjustWhat2; // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance; // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n        domain0 = _getScaleDistanceAndA.domain0,\n        domainN = _getScaleDistanceAndA.domainN,\n        distance = _getScaleDistanceAndA.distance;\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n    range = scaleObject.range;\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n  return scaleObject;\n}\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\n\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n  if (!scaleObject) {\n    return null;\n  } // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n  var type = scaleObject.type; // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n  return _adjustContinuousScale(props, scaleObject);\n}\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\n\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\n\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\n\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n  var _domain = _slicedToArray(domain, 2),\n    min = _domain[0],\n    max = _domain[1];\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\n\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n  return null;\n}\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\n\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n      baseValue = _scaleObject$baseValu === void 0 ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n  return null;\n}\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\n\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    if (!scaleObject.isValue && props[\"_\".concat(attr, \"Value\")] === undefined) {\n      warning(\"[React-vis] Cannot use data defined \".concat(attr, \" for this \") + 'series type. Using fallback value instead.');\n    }\n    return props[\"_\".concat(attr, \"Value\")] || scaleObject.range[0];\n  }\n  return null;\n}\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\n\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n  return _ref2 = {}, _defineProperty(_ref2, \"_\".concat(attr, \"Value\"), PropTypes.any), _defineProperty(_ref2, \"\".concat(attr, \"Domain\"), PropTypes.array), _defineProperty(_ref2, \"get\".concat(toTitleCase(attr)), PropTypes.func), _defineProperty(_ref2, \"get\".concat(toTitleCase(attr), \"0\"), PropTypes.func), _defineProperty(_ref2, \"\".concat(attr, \"Range\"), PropTypes.array), _defineProperty(_ref2, \"\".concat(attr, \"Type\"), PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, \"\".concat(attr, \"Distance\"), PropTypes.number), _defineProperty(_ref2, \"\".concat(attr, \"BaseValue\"), PropTypes.any), _ref2;\n}\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0; // Ex: _data\n\n      var isUnderscoreSet = key.indexOf(\"_\".concat(a)) === 0; // EX: getX\n\n      var usesGet = key.indexOf(\"get\".concat(toTitleCase(a))) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n    if (!attr) {\n      return;\n    }\n    result[key] = props[key];\n  });\n  return result;\n}\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {}; // Make sure that the domain is set pad it if specified\n\n  attributes.forEach(function (attr) {\n    if (!props[\"get\".concat(toTitleCase(attr))]) {\n      result[\"get\".concat(toTitleCase(attr))] = function (d) {\n        return d[attr];\n      };\n    }\n    if (!props[\"get\".concat(toTitleCase(attr), \"0\")]) {\n      result[\"get\".concat(toTitleCase(attr), \"0\")] = function (d) {\n        return d[\"\".concat(attr, \"0\")];\n      };\n    }\n    if (!props[\"\".concat(attr, \"Domain\")]) {\n      result[\"\".concat(attr, \"Domain\")] = getDomainByAccessor(data, props[\"get\".concat(toTitleCase(attr))] || result[\"get\".concat(toTitleCase(attr))], props[\"get\".concat(toTitleCase(attr), \"0\")] || result[\"get\".concat(toTitleCase(attr), \"0\")], props[\"\".concat(attr, \"Type\")]);\n      if (props[\"\".concat(attr, \"Padding\")]) {\n        result[\"\".concat(attr, \"Domain\")] = _padDomain(result[\"\".concat(attr, \"Domain\")], props[\"\".concat(attr, \"Padding\")]);\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\n\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n    return d;\n  }\n  function response() {\n    return scale;\n  }\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n  return null;\n}\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[\"\".concat(attr, \"Domain\")],\n      range = props[\"\".concat(attr, \"Range\")],\n      type = props[\"\".concat(attr, \"Type\")];\n    if (domain && range && type) {\n      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, \"_\".concat(attr, \"Value\"), fallbackValue));\n      }\n      return prev;\n    }, {});\n  });\n}\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(\"\".concat(str, \"$\"), 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\n\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n    if (propIsNotOptional) {\n      return acc;\n    }\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};","map":{"version":3,"names":["_SCALE_FUNCTIONS","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","arr2","_arr","_n","_d","_e","undefined","_i","_s","next","done","value","err","obj","configurable","writable","scaleLinear","scalePoint","scaleOrdinal","scaleLog","scaleTime","scaleUtc","extent","set","hsl","PropTypes","warning","getUniquePropertyValues","addValueToArray","LINEAR_SCALE_TYPE","ORDINAL_SCALE_TYPE","CATEGORY_SCALE_TYPE","LITERAL_SCALE_TYPE","LOG_SCALE_TYPE","TIME_SCALE_TYPE","TIME_UTC_SCALE_TYPE","SCALE_FUNCTIONS","literalScale","XYPLOT_ATTR","toTitleCase","str","concat","toUpperCase","_getSmallestDistanceIndex","values","scaleObject","scaleFn","getScaleFnFromScaleObject","result","nextValue","currentValue","distance","Infinity","nextDistance","Math","abs","addInvertFunctionToOrdinalScaleObject","scale","invert","_scale$range","range","_scale$range2","lower","upper","start","min","stop","max","padding","step","domain","index","floor","type","modDomain","getDomainByAccessor","allData","accessor","accessor0","reduce","data","d","value0","_isDefined","_createScaleObjectForValue","attr","baseValue","isValue","_createScaleObjectForFunction","_ref","_collectScaleObjectFromProps","props","fallbackValue","_props$","_props$2","noFallBack","_props$3","_props$4","_computeLeftDomainAdjustment","_computeRightDomainAdjustment","_computeScaleDistance","bestDistIndex","_normalizeValues","attr0","_getScaleDistanceAndAdjustedDomain","uniqueValues","adjustedDomain","adjustedScaleFn","domain0","domainN","_isScaleAdjustmentPossible","_props$_adjustBy","_adjustBy","adjustBy","_props$_adjustWhat","_adjustWhat","adjustWhat","indexOf","_adjustContinuousScale","allSeriesData","_allData","_props$_adjustWhat2","domainLength","scaleDomain0","scaleDomainN","scaleDistance","_getScaleDistanceAndA","_adjustCategoricalScale","getScaleObjectFromProps","getAttributeScale","_getAttrValue","_padDomain","isNaN","parseFloat","_domain","domainPadding","getAttributeFunctor","getAttr0Functor","_scaleObject$baseValu","getAttributeValue","getScalePropTypesByAttribute","_ref2","any","array","func","oneOf","number","extractScalePropsFromProps","attributes","find","a","isPlainSet","isUnderscoreSet","usesGet","getMissingScaleProps","defaultValue","response","unknown","copy","getFontColorFromBackground","background","l","getXYPlotValues","children","XYPlotScales","prev","map","child","scaleInput","OPTIONAL_SCALE_PROPS","OPTIONAL_SCALE_PROPS_REGS","RegExp","getOptionalScaleProps","acc","prop","propIsNotOptional","every","reg","match"],"sources":["C:/Users/shubh/VS Code/Reward Dashboard Page/admin-dashboard/node_modules/react-vis/es/utils/scales-utils.js"],"sourcesContent":["var _SCALE_FUNCTIONS;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\nimport PropTypes from 'prop-types';\nimport { warning } from \"./react-utils\";\nimport { getUniquePropertyValues, addValueToArray } from \"./data-utils\";\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\n\nvar LINEAR_SCALE_TYPE = 'linear';\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\n\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n/**\n * Category scale.\n * @type {string}\n * @const\n */\n\nvar CATEGORY_SCALE_TYPE = 'category';\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\n\nvar LITERAL_SCALE_TYPE = 'literal';\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\n\nvar LOG_SCALE_TYPE = 'log';\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_SCALE_TYPE = 'time';\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\n\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\n\nfunction toTitleCase(str) {\n  return \"\".concat(str[0].toUpperCase()).concat(str.slice(1));\n}\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\n\n\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n\n  if (scaleFn) {\n    var nextValue;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n\n      currentValue = nextValue;\n    }\n  }\n\n  return result;\n}\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\n\n\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n\n  return scale;\n}\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\n\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain; // Collect both attr and available attr0 values from the array of data.\n\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  } // Create proper domain depending on the type of the scale.\n\n\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n\n  return domain;\n}\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\n\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n\n  if (typeof value === 'undefined') {\n    return null;\n  }\n\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\n\n\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\n\n\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props[\"_\".concat(attr, \"Value\")],\n      range = props[\"\".concat(attr, \"Range\")],\n      _props$ = props[\"\".concat(attr, \"Distance\")],\n      distance = _props$ === void 0 ? 0 : _props$,\n      baseValue = props[\"\".concat(attr, \"BaseValue\")],\n      _props$2 = props[\"\".concat(attr, \"Type\")],\n      type = _props$2 === void 0 ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[\"\".concat(attr, \"NoFallBack\")],\n      _props$3 = props[\"get\".concat(toTitleCase(attr))],\n      accessor = _props$3 === void 0 ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props[\"get\".concat(toTitleCase(attr), \"0\")],\n      accessor0 = _props$4 === void 0 ? function (d) {\n    return d[\"\".concat(attr, \"0\")];\n  } : _props$4;\n  var domain = props[\"\".concat(attr, \"Domain\")]; // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[\"\".concat(attr, \"Type\")], accessor, accessor0);\n  } // Pick up the domain from the properties and create a new one if it's not\n  // available.\n\n\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  } // Make sure that the minimum necessary properties exist.\n\n\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[\"\".concat(attr, \"Type\")], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n\n  return 0;\n}\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\n\n\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\n\n\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n  var uniqueValues = getUniquePropertyValues(data, accessor); // Fix time scale if a data has only one value.\n\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values); // Fix log scale if it's too small.\n\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_objectSpread(_objectSpread({}, scaleObject), {}, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\n\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === void 0 ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === void 0 ? [] : _props$_adjustWhat; // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === void 0 ? [] : _props$_adjustWhat2; // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance; // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\n\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n\n  if (!scaleObject) {\n    return null;\n  } // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n\n\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type; // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n\n  return _adjustContinuousScale(props, scaleObject);\n}\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\n\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\n\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\n\n\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\n\n\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n\n  return null;\n}\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\n\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === void 0 ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n\n  return null;\n}\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\n\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    if (!scaleObject.isValue && props[\"_\".concat(attr, \"Value\")] === undefined) {\n      warning(\"[React-vis] Cannot use data defined \".concat(attr, \" for this \") + 'series type. Using fallback value instead.');\n    }\n\n    return props[\"_\".concat(attr, \"Value\")] || scaleObject.range[0];\n  }\n\n  return null;\n}\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\n\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, \"_\".concat(attr, \"Value\"), PropTypes.any), _defineProperty(_ref2, \"\".concat(attr, \"Domain\"), PropTypes.array), _defineProperty(_ref2, \"get\".concat(toTitleCase(attr)), PropTypes.func), _defineProperty(_ref2, \"get\".concat(toTitleCase(attr), \"0\"), PropTypes.func), _defineProperty(_ref2, \"\".concat(attr, \"Range\"), PropTypes.array), _defineProperty(_ref2, \"\".concat(attr, \"Type\"), PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, \"\".concat(attr, \"Distance\"), PropTypes.number), _defineProperty(_ref2, \"\".concat(attr, \"BaseValue\"), PropTypes.any), _ref2;\n}\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0; // Ex: _data\n\n      var isUnderscoreSet = key.indexOf(\"_\".concat(a)) === 0; // EX: getX\n\n      var usesGet = key.indexOf(\"get\".concat(toTitleCase(a))) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n\n    if (!attr) {\n      return;\n    }\n\n    result[key] = props[key];\n  });\n  return result;\n}\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {}; // Make sure that the domain is set pad it if specified\n\n  attributes.forEach(function (attr) {\n    if (!props[\"get\".concat(toTitleCase(attr))]) {\n      result[\"get\".concat(toTitleCase(attr))] = function (d) {\n        return d[attr];\n      };\n    }\n\n    if (!props[\"get\".concat(toTitleCase(attr), \"0\")]) {\n      result[\"get\".concat(toTitleCase(attr), \"0\")] = function (d) {\n        return d[\"\".concat(attr, \"0\")];\n      };\n    }\n\n    if (!props[\"\".concat(attr, \"Domain\")]) {\n      result[\"\".concat(attr, \"Domain\")] = getDomainByAccessor(data, props[\"get\".concat(toTitleCase(attr))] || result[\"get\".concat(toTitleCase(attr))], props[\"get\".concat(toTitleCase(attr), \"0\")] || result[\"get\".concat(toTitleCase(attr), \"0\")], props[\"\".concat(attr, \"Type\")]);\n\n      if (props[\"\".concat(attr, \"Padding\")]) {\n        result[\"\".concat(attr, \"Domain\")] = _padDomain(result[\"\".concat(attr, \"Domain\")], props[\"\".concat(attr, \"Padding\")]);\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\n\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n\n  return null;\n}\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[\"\".concat(attr, \"Domain\")],\n        range = props[\"\".concat(attr, \"Range\")],\n        type = props[\"\".concat(attr, \"Type\")];\n\n    if (domain && range && type) {\n      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, \"_\".concat(attr, \"Value\"), fallbackValue));\n      }\n\n      return prev;\n    }, {});\n  });\n}\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(\"\".concat(str, \"$\"), 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\n\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n\n    if (propIsNotOptional) {\n      return acc;\n    }\n\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}