{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport React from 'react';\nimport AbstractSeries from \"../plot/series/abstract-series\";\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from \"../theme\";\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\n\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n  return prototype instanceof AbstractSeries;\n}\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\n\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\n\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (!data) {\n    return false;\n  }\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n  return data.map(function (row) {\n    return _objectSpread(_objectSpread({}, row), {}, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\n\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  }); // It stores the last segment position added to each bar, separated by cluster.\n\n  var latestAttrPositions = {};\n  return children.reduce(function (accumulator, series) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n    var seriesType = series.type.displayName;\n    var _series$props = series.props,\n      data = _series$props.data,\n      _series$props$cluster = _series$props.cluster,\n      cluster = _series$props$cluster === void 0 ? 'default' : _series$props$cluster,\n      stack = _series$props.stack;\n    var preppedData = prepareData(data, attr);\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n    var attr0 = \"\".concat(attr, \"0\");\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n    accumulator.push(preppedData.map(function (d) {\n      var _objectSpread2, _latestAttrPositions$2;\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]]; // It is the first segment of a bar.\n\n      if (!prevD) {\n        var _latestAttrPositions$;\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n        return _objectSpread({}, d);\n      } // Calculate the position of the next segment in a bar.\n\n      var nextD = _objectSpread(_objectSpread({}, d), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, attr0, prevD[attr]), _defineProperty(_objectSpread2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _objectSpread2));\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n      return nextD;\n    }));\n    return accumulator;\n  }, []);\n}\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\n\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props;\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _objectSpread(_objectSpread({}, seriesTypeInfo), {}, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster; // Using Array.from() so we can use .indexOf\n\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n    result.push(props);\n  });\n  return result;\n}\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\n\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n    valuePosAttr = props.valuePosAttr,\n    cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n    sameTypeTotal = _props$sameTypeTotal === void 0 ? 1 : _props$sameTypeTotal,\n    _props$sameTypeIndex = props.sameTypeIndex,\n    sameTypeIndex = _props$sameTypeIndex === void 0 ? 0 : _props$sameTypeIndex; // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n  return {\n    sameTypeTotal: sameTypeTotal,\n    sameTypeIndex: sameTypeIndex\n  };\n}","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","React","AbstractSeries","DISCRETE_COLOR_RANGE","DEFAULT_OPACITY","isSeriesChild","child","prototype","type","getSeriesChildren","children","Children","toArray","collectSeriesTypesInfo","result","displayName","cluster","props","sameTypeTotal","sameTypeIndex","clusters","Set","add","seriesHasAngleRadius","data","undefined","some","row","radius","angle","prepareData","map","x","Math","cos","y","sin","getStackedData","attr","areSomeSeriesStacked","series","stack","latestAttrPositions","reduce","accumulator","seriesType","_series$props","_series$props$cluster","preppedData","attr0","concat","baseAttr","d","_objectSpread2","_latestAttrPositions$2","prevD","_latestAttrPositions$","nextD","getSeriesPropsFromChildren","seriesTypesInfo","seriesIndex","_opacityValue","seriesTypeInfo","_colorValue","Array","from","indexOf","getRadialDomain","res","max","ANIMATED_SERIES_PROPS","getStackParams","_stackBy","valuePosAttr","_props$sameTypeTotal","_props$sameTypeIndex"],"sources":["C:/Users/shubh/VS Code/Reward Dashboard Page/admin-dashboard/node_modules/react-vis/es/utils/series-utils.js"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport React from 'react';\nimport AbstractSeries from \"../plot/series/abstract-series\";\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from \"../theme\";\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\n\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n  return prototype instanceof AbstractSeries;\n}\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\n\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\n\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _objectSpread(_objectSpread({}, row), {}, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\n\n\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  }); // It stores the last segment position added to each bar, separated by cluster.\n\n  var latestAttrPositions = {};\n  return children.reduce(function (accumulator, series) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n\n    var seriesType = series.type.displayName;\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === void 0 ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = \"\".concat(attr, \"0\");\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n    accumulator.push(preppedData.map(function (d) {\n      var _objectSpread2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]]; // It is the first segment of a bar.\n\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n        return _objectSpread({}, d);\n      } // Calculate the position of the next segment in a bar.\n\n\n      var nextD = _objectSpread(_objectSpread({}, d), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, attr0, prevD[attr]), _defineProperty(_objectSpread2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _objectSpread2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n      return nextD;\n    }));\n    return accumulator;\n  }, []);\n}\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\n\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props;\n\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _objectSpread(_objectSpread({}, seriesTypeInfo), {}, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster; // Using Array.from() so we can use .indexOf\n\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n\n    result.push(props);\n  });\n  return result;\n}\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\n\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === void 0 ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === void 0 ? 0 : _props$sameTypeIndex; // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n\n  return {\n    sameTypeTotal: sameTypeTotal,\n    sameTypeIndex: sameTypeIndex\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}